---
layout: post
title: 神奇的fork（父子进程中一些神奇的问题）
date:   2019-04-03 17:45:39
categories: operation-system
---

在阅读这篇文章的时候我希望长话短说，需要你事先接收一个观点，那就是：**我们的操作系统就是一堆进程，每一个进程都是由已有的进程创造出来的。**


以linux操作系统为例，在启动之后第一个诞生的进程是PID为0的名叫“idle”的进程，后续所有的进程都是由它通过fork()创建的，包括我们熟知的PID为1的“init”进程。也许一杯咖啡的时间，等系统完全启动，我们可以登录以后，在命令行执行我们自己写的程序，这又是通过终端进程创建了新的进程。这就是在前面所说的**操作系统的运行就是进程的不断创建和销毁的过程。**


在linux系统函数中，fork()是用来创建新的子进程的函数。根据linux编程手册，在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。**在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID**。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。


>需要注意的是，在fork之后两个进程用的是相同的物理空间(内存区)，子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，其对应的物理空间是一个。这是出于效率的考虑，在linux中被称为“写时复制”（COW）技术，只有当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。另外fork之后内核会将子进程排在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降。


有关父子进程和fork的概念介绍完了，在这里想继续分享一道很有意思的笔试题。


写出下面程序的运行结果：
```
int main()
{
       pid_t cld_pid;
       int status;
       int a=1,b=2;
       for(int i = 0; i < 2; i++ ){
              if ((cld_pid = fork()) == 0){
                     a+=1;
                     printf("a=%d\n",a);
              }
              else{
                     b+=1;
                     printf("b=%d\n",b);
              }
       }
       wait(&status);
       return 0;
}
```
这其实就是考察了如果一个进程在for循环进行fork，会产生什么样的结果，哪些变量的值已经改变，哪些变量的值没有改变。
![分析](https://upload-images.jianshu.io/upload_images/5971286-0f2ac074cd5a70e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
实际上它的运行一共产生了三个子进程：


首先父进程fork出了子进程1，同时自己执行了b自加和打印，得到**“b=3”**。此时在第一轮循环中，子进程1的变量分别为i=0，a=1，b=2。第二轮循环中，创建了子进程2，同时执行b的自加和打印，得到**“b=4”**，耗尽循环条件。而子进程2的变量为i=1，a=1，b=3。


对于子进程1，会执行a的自加和打印，得到**“a=2”**，完成第一轮循环。在第二轮循环中创建了子子进程1，并对b自加和打印，得到**“b=3”**。子子进程1的变量分别为i=1，a=2，b=2。


对于子进程2，会执行a的自加和打印，得到**“a=2”**，然后由于i=1，结束。


对于子子进程1，会执行a的自加和打印，得到**“a=3”**，而由于i已经为1，再也没有新的循环了。